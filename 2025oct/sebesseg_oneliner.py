(lambda f,s={"o_m": 0, "lns": [], "prev_sl": 90, "prev_city": None, "prev_sym": "%"}: [s.update({"o_m": int(f.readline()), "lns": [[int(ln[0]), (lambda row: s.update({"prev_sl": row}) or row)(int(ln[1]) if ln[1].isnumeric() else ( (50 if s["prev_city"] else 90) if ln[1] in ["%", "#"] else (90 if ln[1] == "]" else (50 if len(ln[1])>=4 else s["prev_sl"])))), (lambda row: s.update({"prev_city": row}) or row)(ln[1] if len(ln[1]) >= 4 else (None if s["prev_sym"] == "]" else s["prev_city"])), (lambda row: s.update({"prev_sym": row}) or row)(ln[1])] for ln in (raw_ln.strip().split() for raw_ln in f)]}), f.close(), print(f"2. feladat\nA települések neve:\n{'\n'.join([x[2] for x in s['lns'] if x[2] is not None and len(x[3]) >= 4])}"), (lambda q_km: print(f"\n3. feladat\nAz első {q_km} km-en {min([lim for dist, lim, _, __ in s["lns"] if dist <= q_km * 1000])} km/h volt a legalacsonyabb megengedett sebesség."))(float(input("\nAdja meg a vizsgált szakasz hosszát km-ben! "))), print(f"\n4. feladat\nAz út {round((__import__("functools").reduce(lambda acc, item: {"ss": item[0] if len(item[3])>=4 and acc["ss"] == 0 else (0 if item[3] == "]" and acc["ss"] != 0 else acc["ss"]), "dc": acc["dc"] + item[0] - acc["ss"] if item[3] == "]" and acc["ss"] != 0 else acc["dc"]}, s["lns"], {"ss": 0, "dc": 0})["dc"] / s["o_m"])*100, 2)} százaléka vezet településen belül.\n\n5. feladat"), (lambda city_lns: print(f"A sebességkorlátozó táblák száma: {len([x for x in city_lns if x[3].isnumeric()])}\nAz út hossza a településen belül {city_lns[-1][0] - city_lns[0][0]} méter.\n\n6. feladat\nA legközelebbi település: {(lambda prev_city, next_city: (prev_city if next_city[0] == 0 or prev_city[0] <= next_city[0] else next_city)[1])(next(((city_lns[0][0] - d, c) for d,_,c,_ in reversed(s["lns"]) if d < city_lns[0][0] and c), (0, None)), next(((d - city_lns[-1][0], c) for d,_,c,_ in s["lns"] if d>city_lns[-1][0] and c), (0, None)))}"))((lambda sq: [x for x in s["lns"] if x[2] == sq])(input("Adja meg egy település nevét! ")))])(open("ut.txt"))
